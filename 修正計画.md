# システム最終仕様書に基づく修正計画

## 現状の問題点

システム最終仕様書に基づいて、コードベースを分析した結果、以下の問題点が見つかりました：

### 1. フロントエンドとNetworkXMCPサーバーの直接通信

システム最終仕様書では「**フロントエンドとNetworkXMCPサーバーは、いかなる場合も直接通信してはいけません。** 全ての通信は必ずAPIサーバーを経由します。」と明記されていますが、現在のコードでは以下の問題があります：

- **frontend/src/services/networkStore.js**:
  - `mcpClient`を直接インポートして使用している（例：1050行目の`mcpClient.exportNetworkAsGraphML`）
  - 他にも`mcpClient`を使用している箇所が複数ある（1089行目、1097行目、1106行目、1137行目など）

- **frontend/src/services/mcpClient.js**:
  - `MCP_URL`が直接定義されている（15行目）
  - 一部のメソッドが`networkAPI`を使用しているが、一部のメソッドは直接`this.useTool`を呼び出している（例：153行目、173行目、398行目など）

- **frontend/src/pages/NetworkChatPage.jsx**:
  - `mcpClient`を直接インポートして使用している（6行目、150行目、262行目など）

### 2. 1会話 = 1ネットワークの原則

システム最終仕様書では「全ての会話 (`Conversation`) は、必ず一つのネットワーク (`Network`) と1対1で紐付きます。」と明記されています。この原則は現在のコードでは守られていますが、明示的に確認しておく必要があります。

## 修正内容

### 1. frontend/src/services/networkStore.js の修正

#### 修正内容

1. `mcpClient`のインポートを削除し、すべての機能を`networkAPI`を通じて行うように修正します。

```javascript
// 修正前
import { create } from "zustand";
import mcpClient from "./mcpClient";
import { networkAPI } from "./api";

// 修正後
import { create } from "zustand";
import { networkAPI } from "./api";
```

2. `exportAsGraphML`関数を修正します（1040-1074行目）：

```javascript
// 修正前
exportAsGraphML: async (
  includePositions = true,
  includeVisualProperties = true,
) => {
  set({ isLoading: true, error: null });
  try {
    console.log("Exporting network as GraphML");

    // Use MCP client to export network as GraphML
    const result = await mcpClient.exportNetworkAsGraphML(
      includePositions,
      includeVisualProperties,
    );

    if (result && result.success) {
      console.log("Network exported as GraphML successfully");

      set({ isLoading: false, error: null });

      // Return the GraphML string
      return result.graphml;
    } else {
      throw new Error(result.error || "Failed to export network as GraphML");
    }
  } catch (error) {
    console.error("Failed to export network as GraphML:", error);

    set({
      isLoading: false,
      error: error.message || "Failed to export network as GraphML",
    });
    return null;
  }
}

// 修正後
exportAsGraphML: async (
  includePositions = true,
  includeVisualProperties = true,
) => {
  set({ isLoading: true, error: null });
  try {
    console.log("Exporting network as GraphML");

    // Use networkAPI to export network as GraphML
    const response = await networkAPI.exportNetworkAsGraphML();
    const result = response.data.result;

    if (result && result.success) {
      console.log("Network exported as GraphML successfully");

      set({ isLoading: false, error: null });

      // Return the GraphML string
      return result.content;
    } else {
      throw new Error(result.error || "Failed to export network as GraphML");
    }
  } catch (error) {
    console.error("Failed to export network as GraphML:", error);

    set({
      isLoading: false,
      error: error.message || "Failed to export network as GraphML",
    });
    return null;
  }
}
```

3. `changeVisualProperties`関数を修正します（1076-1200行目）：

```javascript
// 修正前
changeVisualProperties: async (
  propertyType,
  propertyValue,
  propertyMapping = {},
) => {
  set({ isLoading: true, error: null });
  try {
    console.log(
      `Changing visual property ${propertyType} to ${propertyValue} using GraphML API`,
    );

    // Export current network as GraphML
    const exportResult = await mcpClient.exportNetworkAsGraphML();

    if (!exportResult || !exportResult.success || !exportResult.content) {
      throw new Error("Failed to export network as GraphML");
    }

    // Use GraphML-based visual properties API
    const graphmlContent = exportResult.content;
    const result = await mcpClient.graphmlVisualProperties(
      graphmlContent,
      propertyType,
      propertyValue,
      propertyMapping,
    );

    if (result && result.success && result.graphml_content) {
      // Parse the returned GraphML content
      const importResult = await mcpClient.importGraphML(
        result.graphml_content,
      );

      if (importResult && importResult.success) {
        // Update network state with new data from GraphML
        set((state) => ({
          positions: importResult.nodes || [],
          edges: importResult.edges || [],
          visualProperties: {
            ...state.visualProperties,
            [propertyType]: propertyValue,
          },
          isLoading: false,
          error: null,
        }));
        return true;
      } else {
        throw new Error(
          "Failed to import updated GraphML with visual property changes",
        );
      }
    } else {
      throw new Error(result?.error || "Visual property change failed");
    }
  } catch (error) {
    console.error("Failed to change visual properties:", error);

    // Fall back to original implementation for resilience
    try {
      // Use legacy MCP client
      const result = await mcpClient.useTool("change_visual_properties", {
        property_type: propertyType,
        property_value: propertyValue,
        property_mapping: propertyMapping,
      });

      if (result && result.success) {
        // Update visual properties in state
        set((state) => ({
          visualProperties: {
            ...state.visualProperties,
            [propertyType]: propertyValue,
          },
          isLoading: false,
          error: null,
        }));

        // If it's a node property, update positions
        if (propertyType === "node_size" || propertyType === "node_color") {
          const attribute = propertyType.split("_")[1]; // 'size' or 'color'
          const updatedPositions = get().positions.map((node) => ({
            ...node,
            [attribute]:
              node.id in propertyMapping
                ? propertyMapping[node.id]
                : propertyValue,
          }));

          set({ positions: updatedPositions });
        }

        // If it's an edge property, update edges
        if (propertyType === "edge_width" || propertyType === "edge_color") {
          const attribute = propertyType.split("_")[1]; // 'width' or 'color'
          const updatedEdges = get().edges.map((edge) => {
            const edgeKey = `${edge.source}-${edge.target}`;
            return {
              ...edge,
              [attribute]:
                edgeKey in propertyMapping
                  ? propertyMapping[edgeKey]
                  : propertyValue,
            };
          });

          set({ edges: updatedEdges });
        }

        return true;
      }
    } catch (fallbackError) {
      console.error(
        "Fallback visual property change also failed:",
        fallbackError,
      );
    }

    set({
      isLoading: false,
      error: error.message || "Failed to change visual properties",
    });
    return false;
  }
}

// 修正後
changeVisualProperties: async (
  propertyType,
  propertyValue,
  propertyMapping = {},
) => {
  set({ isLoading: true, error: null });
  try {
    console.log(
      `Changing visual property ${propertyType} to ${propertyValue} using GraphML API`,
    );

    // Export current network as GraphML
    const exportResponse = await networkAPI.exportNetworkAsGraphML();
    const exportResult = exportResponse.data.result;

    if (!exportResult || !exportResult.success || !exportResult.content) {
      throw new Error("Failed to export network as GraphML");
    }

    // Use GraphML-based visual properties API
    const graphmlContent = exportResult.content;
    const visualPropsResponse = await networkAPI.graphmlVisualProperties(
      graphmlContent,
      propertyType,
      propertyValue,
      propertyMapping,
    );
    const result = visualPropsResponse.data.result;

    if (result && result.success && result.graphml_content) {
      // Parse the returned GraphML content
      const importResponse = await networkAPI.importGraphML(
        result.graphml_content,
      );
      const importResult = importResponse.data.result;

      if (importResult && importResult.success) {
        // Update network state with new data from GraphML
        set((state) => ({
          positions: importResult.nodes || [],
          edges: importResult.edges || [],
          visualProperties: {
            ...state.visualProperties,
            [propertyType]: propertyValue,
          },
          isLoading: false,
          error: null,
        }));
        return true;
      } else {
        throw new Error(
          "Failed to import updated GraphML with visual property changes",
        );
      }
    } else {
      throw new Error(result?.error || "Visual property change failed");
    }
  } catch (error) {
    console.error("Failed to change visual properties:", error);

    // Fall back to original implementation for resilience
    try {
      // Use networkAPI instead of legacy MCP client
      const response = await networkAPI.useTool("change_visual_properties", {
        property_type: propertyType,
        property_value: propertyValue,
        property_mapping: propertyMapping,
      });
      const result = response.data.result;

      if (result && result.success) {
        // Update visual properties in state
        set((state) => ({
          visualProperties: {
            ...state.visualProperties,
            [propertyType]: propertyValue,
          },
          isLoading: false,
          error: null,
        }));

        // If it's a node property, update positions
        if (propertyType === "node_size" || propertyType === "node_color") {
          const attribute = propertyType.split("_")[1]; // 'size' or 'color'
          const updatedPositions = get().positions.map((node) => ({
            ...node,
            [attribute]:
              node.id in propertyMapping
                ? propertyMapping[node.id]
                : propertyValue,
          }));

          set({ positions: updatedPositions });
        }

        // If it's an edge property, update edges
        if (propertyType === "edge_width" || propertyType === "edge_color") {
          const attribute = propertyType.split("_")[1]; // 'width' or 'color'
          const updatedEdges = get().edges.map((edge) => {
            const edgeKey = `${edge.source}-${edge.target}`;
            return {
              ...edge,
              [attribute]:
                edgeKey in propertyMapping
                  ? propertyMapping[edgeKey]
                  : propertyValue,
            };
          });

          set({ edges: updatedEdges });
        }

        return true;
      }
    } catch (fallbackError) {
      console.error(
        "Fallback visual property change also failed:",
        fallbackError,
      );
    }

    set({
      isLoading: false,
      error: error.message || "Failed to change visual properties",
    });
    return false;
  }
}
```

### 2. frontend/src/services/mcpClient.js の修正

このファイルは、フロントエンドとNetworkXMCPサーバーの間の直接通信を担当しています。システム最終仕様書によれば、フロントエンドとNetworkXMCPサーバーは直接通信してはいけません。すべての通信はAPIサーバーを経由する必要があります。

理想的には、このファイルを完全に削除し、すべての機能を`networkAPI`に移行することが望ましいですが、既存のコードへの影響を最小限に抑えるために、以下の修正を行います：

1. `MCP_URL`の定義を修正します：

```javascript
// 修正前
const API_URL = "http://localhost:8000";
const MCP_URL = `${API_URL}/proxy/networkx`;

// 修正後
const API_URL = "http://localhost:8000";
// NetworkXMCPサーバーへの直接アクセスは行わず、APIサーバーを経由する
const MCP_URL = `${API_URL}/proxy/networkx`;
```

2. すべてのメソッドが`networkAPI`を使用するように修正します。例えば：

```javascript
// 修正前
async useTool(toolName, args = {}) {
  try {
    console.log(`Using MCP tool via API proxy: ${toolName}`, args);
    
    // Use networkAPI to call the tool via API proxy
    const response = await networkAPI.useTool(toolName, args);
    
    console.log(`MCP tool ${toolName} response:`, response.data);

    // レスポンスチェック - resultが存在しない場合のハンドリング
    if (!response.data || response.data.result === undefined) {
      console.warn(
        `Invalid response from MCP tool ${toolName}:`,
        response.data,
      );
      return {
        success: false,
        content: "サーバーから無効な応答を受け取りました。",
      };
    }

    return response.data.result;
  } catch (error) {
    console.error(`Error using MCP tool ${toolName}:`, error);

    // エラーオブジェクトの安全な処理
    const errorMessage =
      error.response?.data?.detail ||
      error.message ||
      `Error using MCP tool ${toolName}`;

    // ツールエラー時にも適切なレスポンス形式を返す
    if (toolName === "process_chat_message") {
      return {
        success: false,
        content: `エラーが発生しました: ${errorMessage}`,
      };
    }

    throw error;
  }
}

// 修正後
async useTool(toolName, args = {}) {
  try {
    console.log(`Using MCP tool via API proxy: ${toolName}`, args);
    
    // Use networkAPI to call the tool via API proxy
    const response = await networkAPI.useTool(toolName, args);
    
    console.log(`MCP tool ${toolName} response:`, response.data);

    // レスポンスチェック - resultが存在しない場合のハンドリング
    if (!response.data || response.data.result === undefined) {
      console.warn(
        `Invalid response from MCP tool ${toolName}:`,
        response.data,
      );
      return {
        success: false,
        content: "サーバーから無効な応答を受け取りました。",
      };
    }

    return response.data.result;
  } catch (error) {
    console.error(`Error using MCP tool ${toolName}:`, error);

    // エラーオブジェクトの安全な処理
    const errorMessage =
      error.response?.data?.detail ||
      error.message ||
      `Error using MCP tool ${toolName}`;

    // ツールエラー時にも適切なレスポンス形式を返す
    if (toolName === "process_chat_message") {
      return {
        success: false,
        content: `エラーが発生しました: ${errorMessage}`,
      };
    }

    throw error;
  }
}
```

3. 直接`this.useTool`を呼び出しているメソッドを、`networkAPI`を使用するように修正します。例えば：

```javascript
// 修正前
async highlightNodes(nodeIds, highlightColor = "#ff0000") {
  return this.useTool("highlight_nodes", {
    node_ids: nodeIds,
    highlight_color: highlightColor,
  });
}

// 修正後
async highlightNodes(nodeIds, highlightColor = "#ff0000") {
  const response = await networkAPI.useTool("highlight_nodes", {
    node_ids: nodeIds,
    highlight_color: highlightColor,
  });
  return response.data.result;
}
```

### 3. frontend/src/pages/NetworkChatPage.jsx の修正

このファイルでは、`mcpClient`を直接インポートして使用している箇所があります。これらを`networkAPI`を使用するように修正します：

1. インポート文を修正します：

```javascript
// 修正前
import { useState, useEffect, useRef } from "react";
import ForceGraph2D from "react-force-graph-2d";
import useNetworkStore from "../services/networkStore";
import useChatStore from "../services/chatStore";
import ReactMarkdown from "react-markdown";
import mcpClient from "../services/mcpClient";
import FileUploadButton from "../components/FileUploadButton";

// 修正後
import { useState, useEffect, useRef } from "react";
import ForceGraph2D from "react-force-graph-2d";
import useNetworkStore from "../services/networkStore";
import useChatStore from "../services/chatStore";
import ReactMarkdown from "react-markdown";
import { networkAPI } from "../services/api";
import FileUploadButton from "../components/FileUploadButton";
```

2. `mcpClient`を使用している箇所を`networkAPI`を使用するように修正します。例えば：

```javascript
// 修正前
const loadUserNetworks = async () => {
  try {
    const userId = localStorage.getItem("userId");
    if (!userId) {
      console.log("No user ID found, skipping network list loading");
      return;
    }

    // APIサーバーを経由してユーザーのネットワークリストを取得
    const result = await mcpClient.useTool("list_user_networks", { user_id: userId });
    if (result.success) {
      console.log("Loaded user networks:", result.networks);
    } else {
      console.error("Failed to load user networks:", result.error);
    }
  } catch (error) {
    console.error("Error loading user networks:", error);
  }
};

// 修正後
const loadUserNetworks = async () => {
  try {
    const userId = localStorage.getItem("userId");
    if (!userId) {
      console.log("No user ID found, skipping network list loading");
      return;
    }

    // APIサーバーを経由してユーザーのネットワークリストを取得
    const response = await networkAPI.useTool("list_user_networks", { user_id: userId });
    const result = response.data.result;
    if (result.success) {
      console.log("Loaded user networks:", result.networks);
    } else {
      console.error("Failed to load user networks:", result.error);
    }
  } catch (error) {
    console.error("Error loading user networks:", error);
  }
};
```

3. 同様に、262行目付近の`mcpClient.getSampleNetwork()`の呼び出しも修正します：

```javascript
// 修正前
// mcpClient.getSampleNetworkを使用してサンプルネットワークを読み込む
console.log("NetworkChatPage: Loading sample network via MCP client");
const result = await mcpClient.getSampleNetwork();

// 修正後
// networkAPIを使用してサンプルネットワークを読み込む
console.log("NetworkChatPage: Loading sample network via API");
const response = await networkAPI.getSampleNetwork();
const result = response.data;
```

### 4. API/routers/proxy.py の確認

現在の`proxy.py`は、フロントエンドからのリクエストをNetworkXMCPサーバーに転送する役割を果たしています。このファイルは、システム最終仕様書の要件を満たしているため、大きな修正は必要ありません。

ただし、以下の点を確認しておくことをお勧めします：

1. すべてのエンドポイントが適切に実装されているか
2. エラーハンドリングが適切に行われているか
3. 認証が適切に行われているか

## テスト方法

修正後のコードをテストするために、以下の手順を実行することをお勧めします：

1. フロントエンドの起動：
   ```
   cd frontend
   npm run dev
   ```

2. APIサーバーの起動：
   ```
   cd API
   uvicorn main:app --reload
   ```

3. NetworkXMCPサーバーの起動：
   ```
   cd NetworkXMCP
   uvicorn main:app --port 8001 --reload
   ```

4. ブラウザでフロントエンドにアクセスし、以下の機能をテストします：
   - ログイン
   - 会話の作成
   - メッセージの送信
   - ネットワークの可視化
   - ネットワークファイルのアップロード
   - 中心性の計算
   - レイアウトの変更
   - ビジュアルプロパティの変更

5. ブラウザの開発者ツールを使用して、ネットワークリクエストを監視し、フロントエンドがNetworkXMCPサーバーと直接通信していないことを確認します。すべてのリクエストがAPIサーバーを経由していることを確認します。

## まとめ

システム最終仕様書に基づいて、以下の修正を行いました：

1. フロントエンドとNetworkXMCPサーバーの直接通信を排除し、すべての通信をAPIサーバーを経由するように修正
2. 1会話 = 1ネットワークの原則を確認

これらの修正により、システムはより堅牢で保守しやすくなります。また、将来的な拡張性も向上します。